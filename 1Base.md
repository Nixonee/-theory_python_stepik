
# ==**End x Sep**==
## ==**Параметр sep**==

По умолчанию этот параметр равен символу пробела  . Следующие строки кода являются эквивалентными:

```python
print('aa', 'bb', 'cc')
```

```python
print('aa', 'bb', 'cc', sep=' ')
```

Мы можем изменить параметр `sep` на любую другую строку, например, на символ звёздочки `*`.

Приведённый ниже код:

```python
print('aa', 'bb', 'cc', sep='*')
```

выводит:

```no-highlight
aa*bb*cc
```

Также в качестве параметра `sep` мы можем указать и переменную.

Приведённый ниже код:

```python
minus = '-'
print('aa', 'bb', 'cc', sep=minus)
```

выводит:

```no-highlight
aa-bb-cc
```


## ==**Параметр end**==

По умолчанию параметр `end` равен символу перевода строки (`\n`).

 Следующие строки кода являются эквивалентными:

```python
print("A great man doesn't seek to lead.")
print("He's called to it. And he answers.")
```

```python
print("A great man doesn't seek to lead.", end='\n')
print("He's called to it. And he answers.", end='\n')
```

Если перевод строки делать не нужно или требуется указать специальное окончание для вывода, то следует явно указать значение для параметра `end` (можем указать через переменную, как и с параметром `sep`).

Приведенный ниже код:

```python
minus = '-'
print('a', 'b', 'c', end=minus)
print('second line')
```

выводит:

```no-highlight
a b c-second line
```

По завершении печати первой команды `print()` вставлен символ `-` вместо символа перевода строки `\n`.

## ==**Еnd и sep**==

1) Последовательность символов `\n` называется **управляющей последовательностью** и задаёт перевод строки.

Приведённый ниже код:

```python
print('a', '\n', 'b', '\n', 'c', sep='*', end='#')
```

выводит:

```no-highlight
a*
*b*
*c#
```

2) Параметры `sep` и `end` можно устанавливать одновременно.

Приведённый ниже код:

```python
print('a', 'b', 'c', sep='*', end='finish')
```

выводит:

```no-highlight
a*b*cfinish
```

3) Для разных команд `print()` можно задавать разные параметры `sep` и `end`.

Приведённый ниже код:

```python
arg1 = 'Hello'
sep1 = '_-_'
end2 = '+++'

print(arg1, 'everyone', sep=sep1, end='! ')
print('How', 'are', 'you', 'in', '2024?', sep=' ', end=end2)
```

выводит:

```no-highlight
Hello_-_everyone! How are you in 2024?+++
```

4) Чтобы убрать все дополнительные выводимые символы, можно установить параметры `sep` и `end` команды `print()` как пустые строки (`''`).

Приведённый ниже код:

```python
print('a', 'b', 'c', sep='', end='')
print('d', 'e', 'f', sep='', end='')
```

выводит:

```no-highlight
abcdef
```

5)  Если после вывода данных нужно более одного перевода строки, то можно использовать следующий код:

```python
print('Python', end='\n\n\n')
```


# ==**Циклы**==
## #Цикл**For**

Цикл `for` замечательно работает, если мы заранее знаем, сколько повторений (итераций) нам требуется сделать.
Структура цикла `for` в Python выглядит так:

```python
for название_переменной_цикла in range(количество_повторений):
    блок кода
```

Рассмотрим код, который распечатает 10 раз слово "Привет":

```python
for i in range(10):
    print('Привет')
```

Двоеточие (`:`) в конце строки с инструкцией `for` сообщает интерпретатору Python, что дальше находится **блок команд**. В блок команд входят все строки, расположенные с отступом от строки с инструкцией `for`, вплоть до следующей строки без отступа.
### ==**Range()**==

##### Функция range() с 1 параметром

Рассмотрим программный код:

```python
for i in range(10):
    print('Привет', i)
```

Значение, которое мы указываем в скобках у функции `range()` обозначает количество итераций цикла, при этом переменная `i` принимает последовательно значения: `0, 1, 2, 3, 4, 5, 6, 7, 8, 9`.

Если быть более точным, то мы говорим, что функция `range(stop)` **генерирует последовательность** чисел от `0` до `stop - 1`, а цикл `for` последовательно перебирает эту последовательность.

##### Перегрузка range() с 2 параметрами

Если мы хотим начинать последовательность не с `0`, а с какого-то другого числа, то мы можем использовать **перегрузку функции** `range()` принимающую два параметра. Например, вызов функции `range(1, 5)` сгенерирует последовательность чисел `1, 2, 3, 4`  (будьте внимательны, правая граница не включительна). Если нам нужны числа от 11 до 55 включительно, то мы используем `range(1, 6)`.

Таким образом:

- `range(stop)`: создает последовательность чисел `0, 1, 2, 3, ..., stop - 1`;
- `range(start, stop)`: создает последовательность чисел `start, start + 1, start + 2, ..., stop - 2, stop - 1`.

Напишем программу, которая выводит те числа из промежутка [100;999][100;999], которые оканчиваются на 77.

Используя функцию `range()` с двумя параметрами, получаем:

```python
for i in range(100, 1000):  # перебираем числа от 100 до 999
    if i % 10 == 7:         # используем остаток от деления на 10, для получения последней цифры
        print(i)
```

Обратите внимание, в качестве второго параметра мы передали число 10001000.

##### Перегрузка range() с 3 параметрами

Передавая два параметра в функцию `range()` мы можем генерировать любую последовательность целых чисел с шагом 11. Но, что делать, если нужно поменять шаг? Как быть, если мы хотим сгенерировать последовательность чисел `5, 10, 15, 20, 25`? В этом случае существует еще одна перегрузка функции `range()`, принимающая три параметра: `range(start, stop, step)`. Первый параметр задает **старт последовательности**, второй параметр задает **стоп последовательности** и третий – **шаг генерации** чисел.

Например, вызов функции `range(1, 10, 2)` создаст последовательность чисел `1, 3, 5, 7, 9`, а вызов функции `range(5, 30, 5)` сгенерирует последовательность `5, 10, 15, 20, 25`.

Напишем программу, которая выводит все четные числа из промежутка [56;170][56;170].

Используя функцию `range()` с тремя параметрами, получаем:

```python
for i in range(56, 171, 2):
    print(i)
```

Обратите внимание, мы можем использовать функцию `range()` с двумя параметрами:

```python
for i in range(56, 171):
    if i % 2 == 0:
        print(i)
```

Однако такой код получается менее эффективным.

##### Отрицательный шаг генерации

Если шаг генерации является положительным числом, то генерируемая последовательность будет **возрастать**. Мы можем указать отрицательный шаг генерации (третий параметр), что приведет к генерированию **убывающей** последовательности.

В случае отрицательного шага, мы должны гарантировать, что старт последовательности (первый параметр) больше чем конец последовательности (второй параметр).

Например, вызов функции `range(20, 16, -1)` создаст последовательность чисел `20, 19, 18, 17`, а вызов функции `range(20, 10, -3)` сгенерирует последовательность `20, 17, 14, 11`.

Напишем программу, которая отсчитывает от 5 до 1, а затем выводит текст `Взлетаем!!!`:

```python
for i in range(5, 0, -1):
    print(i, end=' ')
print('Взлетаем!!!')
```

Результатом будет:

```no-highlight
5 4 3 2 1 Взлетаем!!!
```

## #Цикл **While**

Структура цикла `while` в Python выглядит так:

```python
while условие:
    блок кода
```

Рассмотрим код, использующий цикл `while`, который распечатает 1010 раз слово `Привет`:

```python
i = 0
while i < 10:
    print('Привет')
    i += 1
```

Напишем программу, которая считывает числа и выводит их квадраты, пока не будет введено −1−1. При такой постановке задачи мы не можем воспользоваться циклом `for`, так как не знаем, сколько чисел будет предшествовать числу −1−1.

```python
num = int(input())
while num != -1:
    print('Квадрат вашего числа равен:', num * num)
    num = int(input())
```

Цикл `while` очень похож на условный оператор `if`. Разница заключается в том, что в случае с условным оператором соответствующий блок кода будет выполняться только один раз, тогда как с циклом `while` блок кода будет выполнен многократно.

## **break, continue**

### __break__

Иногда бывает нужно **прервать выполнение цикла преждевременно**. Оператор `break` прерывает ближайший цикл `for` или `while`.

Усовершенствуем с помощью оператора `break` программу, проверяющую число на простоту:

```python
num = int(input())
flag = True

for i in range(2, num):
    if num % i == 0:        #  если исходное число делится на какое-либо отличное от 1 и самого себя
        flag = False
        break               # останавливаем цикл если встретили делитель числа        

if flag:  # эквивалентно if flag == True:
    print('Число простое')
else:
    print('Число составное')
```

Как только мы встречаем делитель отличный от 1 и `num`, мы меняем значение сигнальной метки и прерываем цикл, поскольку дальнейшее его выполнение лишено смысла: число гарантированно не является простым.

Напишем программу, которая определяет, содержит ли введенное пользователем число цифру 7.

```python
num = int(input())
number = num
flag = False
while num != 0:
    last_digit = num % 10
    if last_digit == 7:
        flag = True
        break        # прерываем цикл, так как число гарантированно содержит цифру 7
    num //= 10

if flag:  # эквивалентно if flag == True:
    print('Число', number, 'содержит цифру 7')
else:
    print('Число', number, 'не содержит цифру 7')
```

### __continue__

Другая стандартная идиома циклов — пропуск отдельных элементов при переборе. Оператор `continue` позволяет перейти к следующей итерации цикла `for` или `while` до завершения всех команд в теле цикла.

Напишем программу, которая выводит все числа от 1 до 100, кроме чисел 7, 17, 29 и 78.

```python
for i in range(1, 101):
    if i == 7 or i == 17 or i == 29 or i == 78:
        continue  # переходим на следующую итерацию
    print(i)
```


