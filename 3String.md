# **`Срезы`**

| Программный код | Результат    | Пояснение                                                          |
| --------------- | ------------ | ------------------------------------------------------------------ |
| `s[2:5]`        | `cde`        | строка состоящая из символов с индексами 2, 3, 4                   |
| `s[:5]`         | `abcde`      | первые пять символов строки                                        |
| `s[5:]`         | `fghij`      | строка состоящая из символов с индексами от 5 до конца             |
| `s[-2:]`        | `ij`         | последние два символа строки                                       |
| `s[:]`          | `abcdefghij` | вся строка целиком                                                 |
| `s[1:7:2]`      | `bdf`        | строка, состоящая из каждого второго символа с индексами от 1 до 6 |
| `s[::-1]`       | `jihgfedcba` | строка в обратном порядке, так как шаг отрицательный               |

# **`Методы строк`**

Метод – специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения. Таким образом: метод — функция, применяемая к объекту. 

## Методы `конвертации регистра`

### #Метод ==`capitalize()`==

Метод `capitalize()` возвращает копию строки `s`, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр.

Приведённый ниже код:

```python
s = 'foo123#BAR#.'
print(s.capitalize())
```

выводит:

```no-highlight
Foo123#bar#.
```
### #Метод ==`swapcase()`==

Метод `swapcase()` возвращает копию строки `s`, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.

Приведённый ниже код:

```python
s = 'FOO Bar 123 baz qUX'
print(s.swapcase())
```

выводит:

```
foo bAR 123 BAZ Qux
```

### #Метод ==`title()`==

Метод `title()` возвращает копию строки `s`, в которой первый символ каждого слова переводится в верхний регистр.

Этот метод использует довольно простой алгоритм: он не пытается различить важные и неважные слова и не обрабатывает аббревиатуры и апострофы.

Приведённый ниже код:

```python
s = "what's happened to ted's IBM stock?"
print(s.title())
```

выводит:

```
What'S Happened To Ted'S Ibm Stock?
```

### #Метод ==`lower()`==

Метод `lower()` возвращает копию строки `s`, в которой все символы имеют нижний регистр.

Приведённый ниже код:

```python
s = 'FOO Bar 123 baz qUX'
print(s.lower())
```

выводит:

```no-highlight
foo bar 123 baz qux
```

### #Метод ==`upper()`==

Метод `upper()` возвращает копию строки `s`, в которой все символы имеют верхний регистр.

Приведённый ниже код:

```python
s = 'FOO Bar 123 baz qUX'
print(s.upper())
```

выводит:

```no-highlight
FOO BAR 123 BAZ QUX
```

## Методы `Поиск и замена`

Методы поиска и замены строк внутри других строк.

Каждый метод в этой группе поддерживает необязательные аргументы `<start>` и `<end>`. Как и в строковых срезах, действие метода ограничено частью исходной строки, начинающейся с позиции символа `<start>` и продолжающейся вплоть до позиции символа `<end>`, но не включающей её. Если параметр `<start>` указан, а параметр `<end>` нет, то метод применяется к части исходной строки от `<start>` до конца строки. Если параметры не заданы, то подразумевается, что `<start> = 0`, `<end> = len(s)`.

### #Метод ==`count()`==

Метод `count(<sub>, <start>, <end>)` считает количество **непересекающихся** вхождений подстроки `<sub>` в исходную строку `s`.

Приведённый ниже код:

```python
s = 'foo goo moo'
print(s.count('oo'))
print(s.count('oo', 0, 8))  # подсчет с 0 по 7 символ
```

выводит:

```no-highlight
3
2
```

### #Метод ==`startswith()`==

Метод `startswith(<prefix>, <start>, <end>)` определяет, **начинается** ли исходная строка `s` подстрокой `<prefix>`. Метод возвращает значение `True`, если исходная строка начинается с подстроки `<prefix>`, или `False` в противном случае.

Приведённый ниже код:

```python
s = 'foobar'
print(s.startswith('foo'))
print(s.startswith('baz'))
```

выводит:

```no-highlight
True
False
```

### #Метод==`endswith()`==

Метод `endswith(<suffix>, <start>, <end>)` определяет, **оканчивается** ли исходная строка `s` подстрокой `<suffix>`. Метод возвращает значение `True`, если исходная строка оканчивается на подстроку `<suffix>`, или `False` в противном случае.

Приведённый ниже код:

```python
s = 'foobar'
print(s.endswith('bar'))
print(s.endswith('baz'))
```

выводит:

```no-highlight
True
False
```

### #Метод  ==`find(), rfind()`==

Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.

Приведённый ниже код:

```python

s = 'foo bar foo baz foo qux'
print(s.find('bar'))
print(s.find('qu'))
print(s.find('python'))
```

выводит:

```no-highlight
0
4
20
-1
```

Метод `rfind(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>`, начиная с конца строки `s`.

### #Метод  ==`index(), rindex()`==

Метод `index(<sub>, <start>, <end>)` идентичен методу `find(<sub>, <start>, <end>)`, за тем исключением, что он **вызывает ошибку** `ValueError: substring not found` во время выполнения программы, если подстрока `<sub>` не найдена.

Метод `rindex(<sub>, <start>, <end>)` идентичен методу `index(<sub>, <start>, <end>)`, за тем исключением, что он ищет первое вхождение подстроки `<sub>`, начиная с конца строки `s`.

==Методы `find()` и `rfind()` являются более безопасными, чем `index()` и `rindex()`, так как не приводят к возникновению ошибки во время выполнения программы.==

### #Метод ==`strip(), lstrip(), rstrip()`==

##### ==Метод `strip()`== 
возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в начале и конце** строки.

Приведённый ниже код:

```python
s = '     foo bar foo baz foo qux      '
print(s.strip())
```

выводит:

```no-highlight
foo bar foo baz foo qux
```

##### ==Метод` lstrip()`==

Метод `lstrip()` возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в начале** строки.

Приведённый ниже код:

```python
s = '     foo bar foo baz foo qux      '
print(s.lstrip())
```

выводит (символом `⎵` обозначены пробелы):

```no-highlight
foo bar foo baz foo qux⎵⎵⎵⎵⎵⎵
```

##### ==Метод `rstrip()`==

Метод `rstrip()` возвращает копию строки `s`, у которой удалены все пробелы, стоящие **в конце** строки.

Приведённый ниже код:

```python
s = '      foo bar foo baz foo qux      '
print(s.rstrip())
```

выводит (символом `⎵` обозначены пробелы):

```no-highlight
⎵⎵⎵⎵⎵⎵foo bar foo baz foo qux
```

### #Метод ==`replace()`==

Метод `replace(<old>, <new>)` возвращает копию `s` **со всеми** вхождениями подстроки `<old>`, заменёнными на `<new>`.

Приведённый ниже код:

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault'))
```

выводит:

```no-highlight
grault bar grault baz grault qux
```

Метод `replace()` может принимать необязательный третий аргумент `<count>`, который определяет количество замен.

Приведённый ниже код:

```python
s = 'foo bar foo baz foo qux'
print(s.replace('foo', 'grault', 2))
```

выводит:

```no-highlight
grault bar grault baz foo qux
```

## Методы `Классификация символов`

#### #Метод ==`isalnum()`==

Метод `isalnum()` определяет, состоит ли исходная строка из буквенно-цифровых символов. Метод возвращает значение `True`, если исходная строка является непустой и состоит **только** из буквенно-цифровых символов, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = 'abc123'
s2 = 'abc$*123'
s3 = ''

print(s1.isalnum())
print(s2.isalnum())
print(s3.isalnum())
```

выводит:

```no-highlight
True
False
False
```

Обратите внимание, что метод `isalnum()` возвращает значение `True` даже в том случае, когда строка состоит только из буквенных или только из цифровых символов.

Приведённый ниже код:

```python
s1 = 'BEEGEEK'
s2 = '2202'

print(s1.isalnum())
print(s2.isalnum())
```

выводит:

```no-highlight
True
True
```

#### #Метод==`isalpha()`==

Метод `isalpha()` определяет, состоит ли исходная строка из буквенных символов. Метод возвращает значение `True`, если исходная строка является непустой и состоит **только** из буквенных символов, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = 'ABCabc'
s2 = 'abc123'
s3 = ''

print(s1.isalpha())
print(s2.isalpha())
print(s3.isalpha())
```

выводит:

```no-highlight
True
False
False
```

#### #Метод ==`isdigit()`==

Метод `isdigit()` определяет, состоит ли исходная строка **только** из цифровых символов. Метод возвращает значение `True`, если исходная строка является непустой и состоит **только** из цифровых символов, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = '1234567'
s2 = 'abc123'
s3 = ''

print(s1.isdigit())
print(s2.isdigit())
print(s3.isdigit())
```

выводит:

```no-highlight
True
False
False
```

#### #Метод ==`islower()`==

Метод `islower()` определяет, являются ли **все** буквенные символы исходной строки строчными (имеют нижний регистр). Метод возвращает значение `True`, если все буквенные символы исходной строки являются строчными, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = 'abc'
s2 = 'abc1$d'
s3 = 'Abc1$D'

print(s1.islower())
print(s2.islower())
print(s3.islower())
```

выводит:

```no-highlight
True
True
False
```

Обратите внимание, что метод `islower()` **игнорирует все небуквенные символы**.

Приведённый ниже код:

```python
print('1234'.islower())
print('+-*/'.islower())
print('ab#%'.islower())
```

выводит:

```no-highlight
False
False
True
```

В первом и втором случаях у нас в строках отсутствуют буквенные символы в нижнем регистре, поэтому метод `islower()` и возвращает значение `False`.

#### #Метод ==`isupper()`==

Метод `isupper()` определяет, являются ли **все** буквенные символы исходной строки заглавными (имеют верхний регистр). Метод возвращает значение `True`, если все буквенные символы исходной строки являются заглавными, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = 'ABC'
s2 = 'ABC1$D'
s3 = 'Abc1$D'

print(s1.isupper())
print(s2.isupper())
print(s3.isupper())
```

выводит:

```no-highlight
True
True
False
```

Обратите внимание, что метод `isupper()` **игнорирует все небуквенные символы**.

Приведённый ниже код:

```python
print('5678'.isupper())
print('!?_&'.isupper())
print('AB%$'.isupper())
```

выводит:

```no-highlight
False
False
True
```

В первом и втором случаях у нас в строках отсутствуют буквенные символы в верхнем регистре, поэтому метод `isupper()` и возвращает значение `False`.

#### #Метод ==`isspace()`==

Метод `isspace()` определяет, состоит ли исходная строка **только** из пробельных символов. Метод возвращает значение `True`, если строка состоит только из пробельных символов, или `False` в противном случае.

Приведённый ниже код:

```python
s1 = '       '
s2 = 'abc1$d'

print(s1.isspace())
print(s2.isspace())
```

выводит:

```no-highlight
True
False
```

Для пустой строки метод `isspace()` также возвращает `False`, так как в этом случае строка не состоит из пробельных символов.

Приведённый ниже код:

```python
s1 = ''
print(s1.isspace())
```

выводит:

```no-highlight
False
```

### #Метод `format(), f-строки`
#### ==`format()`==
Мы передаем необходимые параметры методу `format()`, а Python ставит их вместо фигурных скобок `{}` – **заполнителей**. Мы можем создавать сколько угодно заполнителей.

Приведенный ниже код:

```python
birth_year = 1992
name = 'Timur'
profession = 'math teacher'
text = 'My name is {}, I was born in {}, I work as a {}.'.format(name, birth_year, profession)

print(text)
```

выводит:

```no-highlight
My name is Timur, I was born in 1992, I work as a math teacher.
```

Для наглядности и гибкости форматирования мы можем использовать порядковый номер в заполнителе: `{0}`, `{1}`, `{2}` и т.д. Такой номер определяет позицию параметра, переданного методу `format()` (нумерация начинается с нуля):

```python
birth_year = 1992
name = 'Timur'
profession = 'math teacher'
text = 'My name is {0}, I was born in {1}, I work as a {2}.'.format(name, birth_year, profession)

print(text)
```

Приведенный ниже код:

```python
name = 'Timur'
city = 'Moscow'
text1 = 'My name is {0}-{0}-{0}!'.format(name, city)
text2 = '{1} is my city and {0} is my name!'.format(name, city)

print(text1)
print(text2)
```

выводит:

```no-highlight
My name is Timur-Timur-Timur!
Moscow is my city and Timur is my name!
```

#### ==`f-строки`==

В Python 3.6 появилась новая разновидность строк — f-строки. Если поставить перед строкой префикс `f`, в заполнители можно будет включить код, например, имя переменной или любые другие выражения. f-строки обеспечивают чистый и интуитивно понятный способ форматирования строк.

Предыдущий код можно записать в виде:

```python
first_name = 'Taylor'
last_name = 'Swift'
country = 'USA'
birth_date = '1989/12/13'
birth_place = 'West Reading, Pennsylvania'
text = f'{first_name} {last_name} is a very famous singer from the {country}. She was born on {birth_date} in {birth_place}.'

print(text)
```

На место заполнителя `{first_name}` встает значение переменной `first_name`, на место заполнителя `{last_name}` встает значение переменной `last_name` и т.д.

Как уже говорилось, помимо переменных в заполнителях f-строк мы можем использовать выражения.

Приведенный ниже код:

```python
print(f'5 + 2 = {5 + 2}')
print(f'5 - 2 = {5 - 2}')
print(f'5 * 2 = {5 * 2}')
print(f'5 / 2 = {5 / 2}')
```

выводит:

```no-highlight
5 + 2 = 7
5 - 2 = 3
5 * 2 = 10
5 / 2 = 2.5
```

### #Метод `split()`

Метод `split()` разбивает строку на слова, используя в качестве разделителя последовательность пробельных символов, и возвращает список из этих слов.

Приведённый ниже код:

```python
s = 'Python is the most powerful language'
words = s.split()
print(words)
```

выводит:

```no-highlight
['Python', 'is', 'the', 'most', 'powerful', 'language']
```

![](https://ucarecdn.com/c9f3ad54-fa80-4bf5-a5d9-b7aaf8f1310b/)

Таким образом, вызов метода `split()` разбивает **строку** на слова и возвращает **список**, содержащий все слова.

Рассмотрим следующий программный код:

```python
numbers = input().split()
```

Если при запуске этой программы ввести строку `1 2 3 4 5`, то список `numbers` будет следующим  `['1', '2', '3', '4', '5']`. Обратите внимание, что список будет состоять из строк (тип `str`), а не из чисел (тип `int`). Если требуется получить именно список чисел, то затем нужно элементы списка по одному преобразовать в числа с помощью команды `int()`.

Приведённый ниже код:

```python
numbers = input().split()
for i in range(len(numbers)):
    numbers[i] = int(numbers[i])
print(numbers)
```

выводит (если на вход программе была подана строка `1 2 3 4 5`):

```no-highlight
[1, 2, 3, 4, 5]
```

#### Необязательный параметр

У метода `split()` есть необязательный параметр, который определяет, какой набор символов будет использоваться в качестве разделителя между элементами списка. Например, вызов метода `split('.')` вернёт список, полученный разделением исходной строки по символу `'.'`.

Приведённый ниже код:

```python
ip = '192.168.1.24'
numbers = ip.split('.')    # указываем явно разделитель
print(numbers)
```

выводит:

```no-highlight
['192', '168', '1', '24']
```

#### ![](https://ucarecdn.com/5e4e3af1-23ed-44cd-a893-93e5cd52b9d8/)

### #Метод `join()`

Метод `join()` собирает строку из элементов списка, используя в качестве разделителя строку, к которой применяется метод.

Приведённый ниже код:

```python
words = ['Python', 'is', 'the', 'most', 'powerful', 'language']
s = ' '.join(words)
print(s)
```

выводит:

```no-highlight
Python is the most powerful language
```

![](https://ucarecdn.com/b32212f5-7b54-4d77-96d4-7f754c6f967e/)

Обратите внимание: все слова разделены одним пробелом, поскольку метод `join()` вызывался на строке, состоящей из одного символа пробела  .

Рассмотрим ещё пару примеров:

```python
words = ['Мы', 'учим', 'язык', 'Python']
print('*'.join(words))
print('-'.join(words))
print('?'.join(words))
print('!'.join(words))
print('*****'.join(words))
print('abc'.join(words))
print('123'.join(words))
```

Приведённый выше код выводит:

```no-highlight
Мы*учим*язык*Python
Мы-учим-язык-Python
Мы?учим?язык?Python
Мы!учим!язык!Python
Мы*****учим*****язык*****Python
МыabcучимabcязыкabcPython
Мы123учим123язык123Python
```

**Запомни:** строковый метод `split()` служит для преобразования строки в список, а метод `join()` — для преобразования списка в строку.

Строковый метод `join()` не работает для списков, у которых элементы не строкового типа данных.

Приведённый ниже код:

```python
numbers = [1, 2, 3, 4]  # список чисел
s = '*'.join(numbers)
print(s)
```

приводит к возникновению ошибки:

```no-highlight
TypeError: sequence item 0: expected str instance, int found
```
