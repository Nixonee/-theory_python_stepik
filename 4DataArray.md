# ==**Списки**==
## `Удаление элементов`

С помощью оператора `del` можно удалять элементы списка по определенному индексу.

Приведённый ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[5]    # удаляем элемент, имеющий индекс 5

print(numbers)
```

 выводит:

```no-highlight
[1, 2, 3, 4, 5, 7, 8, 9]
```

Оператор `del` работает и со срезами: мы можем удалить целый диапазон элементов списка.

Приведённый ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[2:7]    # удаляем элементы с 2 по 6 включительно

print(numbers)
```

 выводит:

```no-highlight
[1, 2, 8, 9]
```

Мы можем удалить все элементы на чётных позициях (`0`, `2`, `4`, `...`) исходного списка.

Приведённый ниже код:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
del numbers[::2]

print(numbers)
```

 выводит:

```no-highlight
[2, 4, 6, 8]
```

## `Распаковка`
### Вывод с помощью #Цикл `for`

Для вывода элементов списка **каждого на отдельной строке** можно использовать следующий код:

**Вариант 1.** Если нужны индексы элементов:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for i in range(len(numbers)):
    print(numbers[i])
```

Мы передаем в функцию `range()` длину списка `len(numbers)`. В нашем случае длина списка `numbers` равна `11`. Таким образом, вызов функции `range(len(numbers))` имеет вид `range(11)`, и переменная цикла `i` последовательно перебирает все значения от `0` до `10`. Это означает, что выражение `numbers[i]` последовательно вернёт все элементы списка `numbers`. Такой способ итерации списка удобен, когда нам нужен не только сам элемент `numbers[i]`, но и его индекс `i`.

**Вариант 2.** Если индексы не нужны:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num)
```

Этот цикл пройдёт по списку `numbers`, придавая переменной цикла `num` значение каждого элемента списка (!) в отличие от предыдущего цикла, в котором переменная цикла «бегала» по индексам списка.

Если требуется выводить  элементы списка на одной строке через пробел, то мы можем использовать необязательный параметр `end` функции `print()`:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for num in numbers:
    print(num, end=' ')
```

###  Вывод с помощью `распаковки` списка

В Python есть удобный способ вывода элементов списка без использования цикла `for`.

**Вариант 1.** Вывод элементов списка через один символ пробела:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers)
```

Приведённый выше код выводит:

```no-highlight
0 1 2 3 4 5 6 7 8 9 10
```

**Вариант 2.** Вывод элементов списка, каждого на отдельной строке:

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(*numbers, sep='\n')
```

Приведённый выше код выводит:

```no-highlight
0
1
2
3
4
5
6
7
8
9
10
```

Поскольку строки содержат символы, подобно тому, как списки содержат элементы, то мы можем использовать распаковку строк точно так же, как и распаковку списков.

Приведённый ниже код:

```python
s = 'Python'

print(*s)
print()
print(*s, sep='\n')
```

выводит

```no-highlight
P y t h o n

P
y
t
h
o
n
```

## `Генераторы списков (list comprehension)`

Пусть 
`word = 'Hello', numbers = [1, 14, 5, 9, 12], words = ['one', 'two', 'three', 'four', 'five', 'six']`.

|Списочное выражение|Результирующий список|
|---|---|
|`[0 for i in range(10)]`|`[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`|
|`[i ** 2 for i in range(1, 8)]`|`[1, 4, 9, 16, 25, 36, 49]`|
|`[i * 10 for i in numbers]`|`[10, 140, 50, 90, 120]`|
|`[c * 2 for c in word]`|`['HH', 'ee', 'll', 'll', 'oo']`|
|`[m[0] for m in words]`|`['o', 't', 't', 'f', 'f', 's']`|
|`[i for i in numbers if i < 10]`|`[1, 5, 9]`|
|`[m[0] for m in words if len(m) == 3]`|`['o', 't', 's']`|
### `Генерация списков`
 **`В Python есть механизм для создания списков из неповторяющихся элементов.`**

Например, для создания списка целых чисел от 00 до 99 мы вынуждены писать такой код:

```python
numbers = []
for i in range(10):
    numbers.append(i)
```

Предыдущий код можно записать следующим образом:

```python
numbers = [i for i in range(10)]
```

Общий вид списочного выражения следующий:

```
[выражение for переменная in последовательность]
```

где `переменная` – имя некоторой переменной, `последовательность` – последовательность значений, которые она принимает (список, строка или объект, полученный при помощи функции `range`), `выражение` – некоторое выражение, как правило, зависящее от использованной в списочном выражении переменной, которым будут заполнены элементы списка.

**`Примеры`**

**1. Создать список, заполненный 1010 нулями можно и при помощи списочного выражения:**

```python
zeros = [0 for i in range(10)]
```

**2. Создать список, заполненный квадратами целых чисел от 00 до 99 можно так:**

```python
squares = [i ** 2 for i in range(10)]
```

**3. Создать список, заполненный кубами целых чисел от 1010 до 2020 можно так:**

```python
cubes = [i ** 3 for i in range(10, 21)]
```

**4. Создать список, заполненный символами строки:**

```python
chars = [c for c in 'abcdefg']
print(chars)
```

### `Считывание входных данных`

Например, если сначала вводится число `n` – количество строк, а затем на вход поступают сами строки, то создать список можно так:

```python
n = int(input())
lines = [input() for _ in range(n)]
```

Можно опустить описание переменной `n`:

```python
lines = [input() for _ in range(int(input()))]
```

Если требуется считать список чисел, то необходимо добавить преобразование типов:

```python
numbers = [int(input()) for _ in range(int(input()))]
```

Обратите внимание, мы используем символ `_` в качестве имени переменной цикла, поскольку она не используется.
### `Условия в списочном выражении
`
В списочных выражениях можно использовать условный оператор. Например, если требуется создать список чётных чисел от 00 до 2020, то мы можем написать такой код:

```python
evens = [i for i in range(21) if i % 2 == 0]
```

### `Вложенные циклы`

В списочном выражении можно использовать вложенные циклы.

Приведённый ниже код:

```python
numbers = [i * j for i in range(1, 5) for j in range(2)]
print(numbers)
```

выводит:

```no-highlight
[0, 1, 0, 2, 0, 3, 0, 4]
```

Приведённый выше код равнозначен следующему:

```python
numbers = []

for i in range(1, 5):
    for j in range(2):
        numbers.append(i * j)
print(numbers)
```

## **`Методы списков`**

Метод – специализированная функция, тесно связанная с объектом. Как и функция, метод вызывается для выполнения отдельной задачи, но он вызывается для определенного объекта и “знает” о своем целевом объекте во время выполнения. Таким образом: метод — функция, применяемая к объекту. 

### #Метод `append()`

Для добавления нового элемента **в конец списка** используется метод `append()`.

Приведённый ниже код:

```python
numbers = [1, 1, 2, 3, 5, 8, 13]  # создаем список

numbers.append(21)  # добавляем число 21 в конец списка
numbers.append(34)  # добавляем число 34 в конец списка

print(numbers)
```

 выводит:

```no-highlight
[1, 1, 2, 3, 5, 8, 13, 21, 34]
```

Обратите внимание, для того чтобы использовать метод `append()`, нужно, чтобы список был создан (при этом он может быть пустым).

Приведённый ниже код:

```python
numbers = []  # создаем пустой список

numbers.append(1)
numbers.append(2)
numbers.append(3)

print(numbers)
```

 выводит:

```no-highlight
[1, 2, 3]
```

### #Метод `extend()`

Можно также расширить список другим списком путём вызова метода `extend()`.

Приведённый ниже код:

```python
numbers = [0, 2, 4, 6, 8, 10]
odds = [1, 3, 5, 7]

numbers.extend(odds)
print(numbers)
```

 выводит:

```no-highlight
[0, 2, 4, 6, 8, 10, 1, 3, 5, 7]
```

Метод `extend()` как бы расширяет один список, добавляя к нему элементы другого списка.

Отличие между методами `append()` и `extend()` проявляется при добавлении строки к списку.

Приведённый ниже код:

```python
words1 = ['iq option', 'stepik', 'beegeek']
words2 = ['iq option', 'stepik', 'beegeek']

words1.append('python')
words2.extend('python')

print(words1)
print(words2)
```

 выводит:

```no-highlight
['iq option', 'stepik', 'beegeek', 'python']
['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']
```

Метод `append()` добавляет строку `'python'` целиком к списку, а метод `extend()` разбивает строку `'python'` на символы `'p'`, `'y'`, `'t'`, `'h'`, `'o'`, `'n'` и их добавляет в качестве элементов списка.

### #Метод `insert()`

Метод `insert()` позволяет вставлять значение в список в заданной позиции. В него передается два аргумента:

1. `index`: индекс, задающий место вставки значения;
2. `value`: значение, которое требуется вставить.

Когда значение вставляется в список, список расширяется в размере, чтобы разместить новое значение. Значение, которое ранее находилось в заданной индексной позиции, и все элементы после него сдвигаются на одну позицию к концу списка.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
print(names)
names.insert(0, 'Anders')
print(names)
names.insert(3, 'Josef')
print(names)
```

выводит:

```no-highlight
['Gvido', 'Roman', 'Timur']
['Anders', 'Gvido', 'Roman', 'Timur']
['Anders', 'Gvido', 'Roman', 'Josef', 'Timur']
```

Если указан недопустимый индекс, то во время выполнения программы не происходит ошибки. Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка. Если применен отрицательный индекс, который указывает на недопустимую позицию, то значение будет вставлено в начало списка.

### #Метод `index()`

Метод `index()` возвращает индекс первого элемента, значение которого равняется переданному в метод значению. Таким образом, в метод передается один параметр:

1. `value`: значение, индекс которого требуется найти.

Если элемент в списке не найден, то во время выполнения происходит ошибка.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
position = names.index('Timur')
print(position)
```

выводит:

```no-highlight
2
```

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
position = names.index('Anders')
print(position)
```

приводит к возникновению ошибки:

```no-highlight
ValueError: 'Anders' is not in list
```

Чтобы избежать таких ошибок, можно использовать метод `index()` вместе с оператором принадлежности `in`:

```python
names = ['Gvido', 'Roman', 'Timur']
if 'Anders' in names:
    position = names.index('Anders')
    print(position)
else:
    print('Такого значения нет в списке')
```

### #Метод `remove()`

Метод `remove()` удаляет первый элемент, значение которого равняется переданному в метод значению. В метод передается один параметр:

1. `value`: значение, которое требуется удалить.

Метод уменьшает размер списка на один элемент. Все элементы после удаленного элемента смещаются на одну позицию к началу списка. Если элемент в списке не найден, то во время выполнения происходит ошибка.

Приведённый ниже код:

```python
food = ['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
print(food)
food.remove('Рис')
print(food)
```

выводит:

```python
['Рис', 'Курица', 'Рыба', 'Брокколи', 'Рис']
['Курица', 'Рыба', 'Брокколи', 'Рис']
```

**Важно:** метод `remove()` удаляет только первый элемент с указанным значением. Все последующие его вхождения остаются в списке. Чтобы удалить все вхождения, нужно использовать цикл `while` в связке с оператором принадлежности `in` и методом `remove`.
### #Метод `pop()`

Метод `pop()` удаляет элемент по указанному индексу и возвращает его. В метод `pop()` передается один **необязательный** аргумент:

1. `index`: индекс элемента, который требуется удалить.

Если индекс не указан, то метод удаляет и возвращает последний элемент списка. Если список пуст или указан индекс за пределами диапазона, то во время выполнения происходит ошибка.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
item = names.pop(1)
print(item)
print(names)
```

выводит:

```no-highlight
Roman
['Gvido', 'Timur']
```

### #Метод `count()`

Метод `count()` возвращает количество элементов в списке, значения которых равны переданному в метод значению. 

Таким образом, в метод передается один параметр:

1. `value`: значение, количество элементов, равных которому, нужно посчитать.

Если значение в списке не найдено, то метод возвращает 0.

Приведённый ниже код:

```python
names = ['Timur', 'Gvido', 'Roman', 'Timur', 'Anders', 'Timur']
cnt1 = names.count('Timur')
cnt2 = names.count('Gvido')
cnt3 = names.count('Josef')

print(cnt1)
print(cnt2)
print(cnt3)
```

выводит:

```no-highlight
3
1
0
```
### #Метод `reverse()`

Метод `reverse()` инвертирует порядок следования значений в списке, то есть меняет его на противоположный.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
names.reverse()
print(names)
```

выводит:

```python
['Timur', 'Roman', 'Gvido']
```

Существует большая разница между вызовом метода `names.reverse()` и использованием среза `names[::-1]`. Метод `reverse()` меняет порядок элементов на обратный **в текущем списке**, а срез создаёт копию списка, в котором элементы следуют в обратном порядке.
### #Метод `clear()
`
Метод `clear()` удаляет все элементы из списка.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
names.clear()
print(names)
```

выводит:

```python
[]
```

### #Метод `copy()`

Метод `copy()` создаёт поверхностную копию списка.

Приведённый ниже код:

```python
names = ['Gvido', 'Roman', 'Timur']
names_copy = names.copy()              # создаем поверхностную копию списка names

print(names)
print(names_copy)
```

выводит:

```python
['Gvido', 'Roman', 'Timur']
['Gvido', 'Roman', 'Timur']
```

Аналогичного результата можно достичь с помощью срезов или функции `list()`:

```python
names = ['Gvido', 'Roman', 'Timur']
names_copy1 = list(names)             # создаем поверхностную копию с помощью функции list()
names_copy2 = names[:]                # создаем поверхностную копию с помощью среза от начала до конца
```

### #Метод `sort()`

В Python списки имеют встроенный метод `sort()`, который сортирует элементы списка по возрастанию или убыванию.

Приведённый ниже код:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort()
print('Отсортированный список:', a)
```

выводит:

```no-highlight
Отсортированный список: [-67, -3, -2, 0, 1, 6, 7, 8, 9, 12, 34, 45, 99, 1000]
```

По умолчанию метод `sort()` сортирует список по возрастанию. Если требуется отсортировать список по убыванию, необходимо явно указать параметр `reverse = True`.

Приведённый ниже код:

```python
a = [1, 7, -3, 9, 0, -67, 34, 12, 45, 1000, 6,  8, -2, 99]
a.sort(reverse=True)  # сортируем по убыванию
print('Отсортированный список:', a)
```

выводит:

```no-highlight
Отсортированный список: [1000, 99, 45, 34, 12, 9, 8, 7, 6, 1, 0, -2, -3, -67]
```

**Примечание 1**. С помощью метода `sort()` можно сортировать списки содержащие не только числа, но и строки. В таком случае элементы списка сортируются в соответствии с [лексикографическим порядком](https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D0%BA%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA).

Приведённый ниже код:

```python
a = ['бета', 'альфа', 'дельта', 'гамма']
a.sort()
print('Отсортированный список:', a)
```

выводит:

```no-highlight
Отсортированный список: ['альфа', 'бета', 'гамма', 'дельта']
```